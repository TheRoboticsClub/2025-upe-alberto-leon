<!-- Tipo de documento e idioma -->
<!DOCTYPE html>
<html lang="es">

<head>

    <!-- Conjunto de caracteres -->
    <meta charset="UTF-8">

    <!-- Adaptación del tamaño de la ventana -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Título de la pestaña del navegador -->
    <title>BLOG DE PRÁCTICAS</title>

    <!-- Estilo CSS de la página -->
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #000000;
        }
        h1 {
            text-align: center;
            color: white;
        }
        p {
            color: white;
        }
        pre {
            background-color: #1e2a35;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 14px;
        }
        code {
            color: #ff0000;
            font-family: monospace;
        }
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
        }
        .header-container img {
            width: 200px;
            height: 200px;
            border-radius: 0;
            object-fit: cover;
        }
        .entry {
            display: none;
            background-color: #000000;
            padding: 15px;
            margin: 10px 0;
            border-left: 5px solid #ff0000;
            color: white;
        }
        .date {
            font-weight: bold;
            color: white;
        }
        .buttons {
            text-align: center;
            margin-bottom: 20px;
        }
        button {
            padding: 10px;
            margin: 5px;
            cursor: pointer;
            border: none;
            background-color: #ff0000;
            color: white;
            border-radius: 5px;
        }
        .screenshot {
            display: block;
            max-width: 100%;
            margin-top: 10px;
        }
    </style>

</head>

<body>

    <!-- Encabezado -->
    <div class="header-container">
        <img src="cover/logo.png" alt="Logo de JdeRobot">
        <h1>BLOG DE PRÁCTICAS EXTERNAS JDEROBOT<br>ALBERTO LEÓN LUENGO</h1>
        <img src="cover/profile_picture.png" alt="Foto de Perfil">
    </div>

    <!-- Párrafo 1 -->
    <p>
        ¡Bienvenido! En esta web se encuentra todo el contenido visto y aprendido en mis 
        Prácticas Externas realizadas con la empresa JdeRobot durante el curso 2025-2026 
        en el Grado en Ingeniería de Robótica Software.
    </p>

    <!-- Párrafo 2 -->
    <p>
        A continuación, se muestran todas las entradas correspondientes a los blogs de prácticas
        realizados durante el transcurso de las mismas, cuyo contenido se divide en las 
        20 semanas que ha durado mi periodo de Prácticas Externas.
    </p>
    
    <!-- Botones de navegación por semana (semanas 01 a 10) -->
    <div class="buttons">
        <button onclick="showEntry(1)">SEMANA 01</button>
        <button onclick="showEntry(2)">SEMANA 02</button>
        <button onclick="showEntry(3)">SEMANA 03</button>
        <button onclick="showEntry(4)">SEMANA 04</button>
        <button onclick="showEntry(5)">SEMANA 05</button>
        <button onclick="showEntry(6)">SEMANA 06</button>
        <button onclick="showEntry(7)">SEMANA 07</button>
        <button onclick="showEntry(8)">SEMANA 08</button>
        <button onclick="showEntry(9)">SEMANA 09</button>
        <button onclick="showEntry(10)">SEMANA 10</button>
    </div>

    <!-- Botones de navegación por semana (semanas 11 a 20) -->
    <div class="buttons">
        <button onclick="showEntry(11)">SEMANA 11</button>
        <button onclick="showEntry(12)">SEMANA 12</button>
        <button onclick="showEntry(13)">SEMANA 13</button>
        <button onclick="showEntry(14)">SEMANA 14</button>
        <button onclick="showEntry(15)">SEMANA 15</button>
        <button onclick="showEntry(16)">SEMANA 16</button>
        <button onclick="showEntry(17)">SEMANA 17</button>
        <button onclick="showEntry(18)">SEMANA 18</button>
        <button onclick="showEntry(19)">SEMANA 19</button>
        <button onclick="showEntry(20)">SEMANA 20</button>
    </div>

    <!-- Entrada de blog (semana 01) -->
    <div id="entry-1" class="entry">
        <p class="date">SEMANA 01: 22-09-2025 al 26-09-2025</p>

        <h1>
            Instalación de Docker en Ubuntu 24.04
        </h1>

        <p>
            En primer lugar, se abre una terminal por defecto en el directorio 
            <strong>HOME</strong>, a través de la cual se irán ejecutando los siguientes 
            comandos:
        </p>

        <p><strong>
            PASO 1: Acceso al escritorio
        </p></strong>
        <pre><code>cd Escritorio/</code></pre>

        <p><strong>
            PASO 2: Clonación del repositorio de RoboticsAcademy
        </p></strong>
        <pre><code>git clone --recurse-submodules https://github.com/JdeRobot/RoboticsAcademy.git</code></pre>

        <p><strong>
            PASO 3: Acceso al repositorio de RoboticsAcademy
        </p></strong>
        <pre><code>cd RoboticsAcademy/</code></pre>

        <p><strong>
            PASO 4: Ejecución del script de preparación
        </p></strong>
        <p>
            Este script intenta configurar el entorno de desarrollo. Al ejecutar este script por
            primera vez, aparecen varios errores, ya que faltan dependencias por instalar 
            (yarn y docker).
        </p>
        <pre><code>./scripts/develop_academy.sh</code></pre>
        <pre><code>./scripts/develop_academy.sh: linea 146: yarn: orden no encontrada<br>./scripts/develop_academy.sh: linea 147: yarn: orden no encontrada<br>./scripts/develop_academy.sh: linea 166: docker: orden no encontrada<br>Cleaning up...<br>./scripts/develop_academy.sh: linea 28: docker: orden no encontrada</code></pre>
    
        <p><strong>
            PASO 5: Ejecución de comandos de configuración
        </p></strong>
        <p>
            Todos los comandos que se ejecutan a continuación se encargan de actualizar los 
            repositorios de APT, instalar las herramientas necesarias (certificados y curl), 
            crear el directorio para las claves de Docker, descargar la clave GPG de 
            Docker, dar permisos de lectura a dicha clave, añadir el repositorio de Docker a 
            APT y volver a actualizar la lista de paquetes.
        </p>
        <pre><code># Add Docker's official GPG key:<br>sudo apt-get update<br>sudo apt-get install ca-certificates curl<br>sudo install -m 0755 -d /etc/apt/keyrings<br>sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc<br>sudo chmod a+r /etc/apt/keyrings/docker.asc<br><br># Add the repository to Apt sources:<br>echo \<br>  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \<br>  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \<br>  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null<br>sudo apt-get update</code></pre>

        <p><strong>
            PASO 6: Instalación de Docker y todos sus componentes
        </p></strong>
        <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre>

        <p><strong>
            PASO 7: Comprobación de la activación de Docker
        </p></strong>
        <pre><code>sudo systemctl status docker</code></pre>

        <p><strong>
            PASO 8: Instalación de Docker Compose
        </p></strong>
        <pre><code>sudo apt install docker-compose</code></pre>

        <p><strong>
            PASO 9: Verificación de la versión de Docker instalada
        </p></strong>
        <pre><code>docker --version</code></pre>

        <p><strong>
            PASO 10: Creación del grupo de usuarios de Docker
        </p></strong>
        <pre><code>sudo groupadd docker</code></pre>

        <p><strong>
            PASO 11: Adición del usuario actual al grupo Docker
        </p></strong>
        <pre><code>sudo usermod -aG docker $USER</code></pre>

        <p><strong>
            PASO 12: Cambio de grupo
        </p></strong>
        <pre><code>newgrp docker</code></pre>

        <p><strong>
            PASO 13: Reejecución del script de preparación
        </p></strong>
        <pre><code>sudo ./scripts/develop_academy.sh</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: Hay que ejecutar el comando con sudo.
        </p>

        <h1>
            Configuración y uso de Docker en Visual Studio Code
        </h1>

        <p><strong>
            PASO 1: Apertura de RoboticsAcademy en Visual Studio Code
        </p></strong>
        <pre><code>cd Escritorio/RoboticsAcademy/</code></pre>
        <pre><code>code .</code></pre>

        <p><strong>
            PASO 2: Instalación de las extensiones de Docker
        </p></strong>
        <p>
            Tras instalar ambas extensiones, es necesario reiniciar el equipo para que 
            Docker y Visual Studio Code se integren correctamente.
        </p>
        <div style="place-items: center">
            <img src="images/semana01/containertools_extension.png" alt="Container Tools Extension" class="screenshot">
        </div>
        <div style="place-items: center">
            <img src="images/semana01/projectmanager_extension.png" alt="Project Manager Extension" class="screenshot">
        </div>
    
        <p><strong>
            PASO 3: Bucle de trabajo a seguir en Visual Studio Code
        </p></strong>
        <p>
            - Hacer los cambios necesarios dentro del directorio 
            <strong>RoboticsInfrastructure/</strong>.<br>
            - Hacer commit y push de dichos cambios en una nueva rama (Publish Branch).<br>
            - Acceder al directorio <strong>RoboticsAcademy/scripts/RADI/</strong>.
        </p>
        <pre><code>cd scripts/RADI/</code></pre>
        <p>
            - Ejecutar el script <strong>build.sh</strong> dentro de la nueva rama.
        </p>
        <pre><code>./build.sh -i &lt;branch_name&gt;</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: Cada vez que se genera un nuevo RADI no se borra el 
            anterior, por lo que el espacio disponible en disco se irá llenando y llenando 
            cada vez que se genere un nuevo RADI hasta que no quede espacio disponible en disco.
            Para evitar que esto ocurra, se debe ejecutar el siguiente comando en la terminal, 
            el cual se encargará de borrar todo el espacio de memoria que se ha ido llenando por 
            cada RADI generado:
        </p>
        <pre><code>docker system prune -af</code></pre>

        <p>
            - Volver al directorio principal.
        </p>
        <pre><code>cd ../..</code></pre>
        <p>
            - Cambiar la siguiente línea del fichero 
            <strong>RoboticsAcademy/compose_cfg/dev_humble_cpu.yaml</strong>.
        </p>
        <pre><code># ANTES<br>  robotics-academy:<br>    image: jderobot/robotics-academy:latest<br><br># DESPUÉS<br>  robotics-academy:<br>    image: jderobot/robotics-academy:test</code></pre>
        <p>
            - Ejecutar el script de preparación (sin sudo) para lanzar el Docker de
            RoboticsAcademy con todos los cambios realizados.
        </p>
        <pre><code>./scripts/develop_academy.sh</code></pre>
        <p>
            - Acceder a la dirección web http://0.0.0.0:7164/ que aparece en la terminal al
            ejecutar el comando anterior para poder entrar a Unibotics en local y verificar
            que los cambios se han realizado correctamente.
        </p>
        <p>
            <strong>IMPORTANTE</strong>: En el caso de que los cambios se hayan realizado 
            únicamente en el fichero <strong>database/universes.sql</strong>, sólo sería 
            necesario realizar el último de todos los pasos que componen este bucle de trabajo, 
            escrito a continuación.
        </p>
        <pre><code>./scripts/develop_academy.sh</code></pre>

        <h1>
            Lanzamiento del RoboticsBackend en local
        </h1>

        <p><strong>
            PASO 1
        </p></strong>
        <p>
            Para lanzar el RoboticsBackend y poder trabajar en Unibotics en local, se debe 
            ejecutar el siguiente comando en la terminal:
        </p>
        <pre><code>docker run --rm -it --device /dev/dri -p 6080:6080 -p 1108:1108 -p 7163:7163 jderobot/robotics-backend:latest</code></pre>
    
        <p><strong>
            PASO 2
        </p></strong>
        <p>
            Se deja ejecutando el comando anterior ejecutando en la terminal y se accede a la 
            <a href="https://unibotics.org/">página web de Unibotics</a>.
        </p>

        <p><strong>
            PASO 3
        </p></strong>
        <p>
            Una vez dentro de Unibotics, se selecciona el ejercicio en el que se quiera
            trabajar.
        </p>
        <p>
            <strong>IMPORTANTE</strong>: Para que todo funcione correctamente, se debe
            seleccionar la opción 'Local ROS2 (RoboticsBackend 4)', que aparece en la esquina 
            superior derecha al hacer clic en la foto de perfil.
        </p>
        <div style="place-items: center">
            <img src="images/semana01/roboticsbackend_option.png" alt="Robotics Backend Option" class="screenshot">
        </div>

        <p><strong>
            PASO 4
        </p></strong>
        <p>
            Verificar que, tanto la simulación en Gazebo como en la terminal, se han lanzado 
            correctamente.
        </p>
        <div style="place-items: center">
            <img src="images/semana01/roboticsbackend_exercise.png" alt="Robotics Backend Local" class="screenshot">
        </div>

        <h1>
            Lanzamiento del RoboticsDatabase junto a RoboticsAcademy en local
        </h1>

        <p><strong>
            PASO 1
        </strong></p>
        <p>
            Para poder lanzar RoboticsDatabase junto a RoboticsAcademy, se debe ejecutar el 
            siguiente comando en la terminal:
        </p>
        <pre><code>docker run --hostname my-postgres --name academy_db -d\<br>    -e POSTGRES_DB=academy_db \<br>    -e POSTGRES_USER=user-dev \<br>    -e POSTGRES_PASSWORD=robotics-academy-dev \<br>    -e POSTGRES_PORT=5432 \<br>    -d -p 5432:5432 \<br>    jderobot/robotics-database:latest</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: Este comando se ejecuta ÚNICAMENTE la primera vez que 
            se lance el RoboticsDatabase junto a RoboticsAcademy.
        </p>

        <p><strong>
            PASO 2
        </strong></p>
        <p>
            Una vez ejecutado el comando anterior, ya no será necesario ejecutarlo
            más veces, ya que lo que ha hecho este comando es crear un nuevo contenedor para 
            RoboticsDatabase, al cual se llamará con el flag --link cuando se vaya a lanzar 
            RoboticsAcademy. A continuación se muestran 3 formas diferentes de lanzar 
            RoboticsDatabase junto a RoboticsAcademy:
        </p>
        <p>
            Lanzamiento de RoboticsDatabase + RoboticsAcademy (NVIDIA + GPU)
        </p>
        <pre><code>docker run --rm -it $(nvidia-smi >/dev/null 2>&1 && echo "--gpus all" || echo "") --device /dev/dri -p 6080:6080 -p 6081:6081 -p 1108:1108 -p 7163:7163 -p 7164:7164 --link academy_db jderobot/robotics-academy:latest</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: Para que este comando funcione, es necesario tener
            instalados los drivers de NVIDIA en Linux.
        </p>
        <p>
            Lanzamiento de RoboticsDatabase + RoboticsAcademy (GPU)
        </p>
        <pre><code>docker run --rm -it --device /dev/dri -p 6080:6080 -p 6081:6081 -p 1108:1108 -p 7163:7163 -p 7164:7164 --link academy_db jderobot/robotics-academy:latest</code></pre>
        <p>
            Lanzamiento de RoboticsDatabase + RoboticsAcademy (CPU)
        </p>
        <pre><code>docker run --rm -it -p 6080:6080 -p 6081:6081 -p 1108:1108 -p 7163:7163 -p 7164:7164 --link academy_db jderobot/robotics-academy:latest</code></pre>

        <p><strong>
            PASO 3
        </strong></p>
        <p>
            Por último, para comprobar que todos los Dockers que se van a utilizar se hayan 
            descargado y configurado correctamente, se debe ejecutar el siguiente comando
            en la terminal:
        </p>
        <pre><code>sudo docker images</code></pre>
        <p>Cuyo resultado debe ser el siguiente:</p>
        <pre><code>REPOSITORY                   TAG       IMAGE ID       CREATED       SIZE<br>jderobot/robotics-backend    latest    0e2a10ccfaf4   5 days ago    27.2GB<br>jderobot/robotics-academy    latest    1c67a50c79c2   13 days ago   28.5GB<br>jderobot/robotics-database   latest    3a1d0407347e   13 days ago   483MB</code></pre>
    </div>
    
    <!-- Entrada de blog (semana 02) -->
    <div id="entry-2" class="entry">
        <p class="date">SEMANA 02: 29-09-2025 al 03-10-2025</p>

        <h1>
            Ejercicio de calentamiento: Cambiar el mundo a un ejercicio
        </h1>

        <p>
            Para ir familiarizándome con el software de RoboticsInfrastructure, se me ha 
            pedido como primer ejercicio cambiar el mundo de Gazebo de uno de los ejercicios 
            que ya se haya migrado a Gazebo Harmonic.
        </p>

        <p>
            En primer lugar, he accedido al fichero 
            <strong>RoboticsInfrastructure/database/universes.sql</strong> para localizar 
            aquellos mundos ya migrados a Gazebo Harmonic.
        </p>
        <p>
            <strong>IMPORTANTE</strong>: La forma más sencilla de identificar los mundos migrados
            a Gazebo Harmonic, es mirando si en su columna <strong>type</strong> aparece escrito 
            <strong>gazebo</strong> o <strong>gz</strong>. En caso de que aparezca escrito 
            <strong>gazebo</strong>, significa que ese mundo todavía se encuentra en Gazebo 11 
            y no se ha migrado. Pero si aparece escrito <strong>gz</strong>, significa que ese 
            mundo ya se ha migrado a Gazebo Harmonic.
        </p>

        <p>
            A continuación se listan todos los mundos que tienen escrito <strong>gz</strong> 
            en su columna <strong>type</strong>, y que podrían utilizarse para llevar a cabo 
            este ejercicio:
        </p>
        <pre><code>12	Laser Mapping Warehouse	/opt/jderobot/Launchers/laser_mapping.launch.py	{"gzsim":"/opt/jderobot/Launchers/visualization/laser_mapping.config"}	ROS2	gz	{0.0,0.0,0.0,0.0,0.0,0.0}<br>25	Vacuums House Markers	/opt/jderobot/Launchers/marker_visual_loc.launch.py	{"gzsim":"/opt/jderobot/Launchers/visualization/marker_visual_loc.config"}	ROS2	gz	{1,-1.5,0.6,0,0,0}<br>31	Rescue People Harmonic	/opt/jderobot/Launchers/rescue_people.launch.py	{"gzsim":"/opt/jderobot/Launchers/visualization/rescue_people.config"}	ROS2	gz	{0.0,0.0,0.0,0.0,0.0,0.0}<br>32	Follow Road Harmonic	/opt/jderobot/Launchers/follow_road.launch.py	{"gzsim":"/opt/jderobot/Launchers/visualization/follow_road.config"}	ROS2	gz	{0.0,0.0,0.0,0.0,0.0,0.0}<br>33	Small Laser Mapping Warehouse	/opt/jderobot/Launchers/small_laser_mapping.launch.py	{"gzsim":"/opt/jderobot/Launchers/visualization/small_laser_mapping.config"}	ROS2	gz	{0.0,0.0,0.0,0.0,0.0,0.0}<br>34	Pick And Place Arm	/home/dev_ws/src/IndustrialRobots/ros2_SimRealRobotControl/ros2srrc_launch/moveit2/moveit2.launch.py	None	ROS2	gazebo	{0.0,0.0,0.0,0.0,0.0,0.0}<br>35	Car Junction	/opt/jderobot/Launchers/car_junction.launch.py	{"gzsim":"/opt/jderobot/Launchers/visualization/car_junction.config"}	ROS2	gz	{0.0,0.0,0.0,0.0,0.0,0.0}<br>36	Drone Gymkhana Harmonic	/opt/jderobot/Launchers/drone_gymkhana.launch.py	None	ROS2	gz	{0.0,0.0,0.0,0.0,0.0,0.0}<br>37	Tower Inspection Harmonic	/opt/jderobot/Launchers/power_tower_inspection.launch.py	None	ROS2	gz	{0.0,0.0,0.0,0.0,0.0,0.0}</code></pre>

        <p>
            En mi caso, he seleccionado los mundos correspondientes a los ejercicios de 
            <strong>Laser Mapping</strong> (número 12) y <strong>Marker Based Visual Loc</strong>
            (número 25). El mundo del <strong>Laser Mapping</strong> es un almacén tipo Amazon, 
            mientras que el mundo del <strong>Marker Based Visual Loc </strong>es una casa de 
            dos plantas.
        </p>

        <p>
            El resultado final de este ejercicio visualizará el almacén del ejercicio
            <strong>Laser Mapping</strong> en la ventana de Gazebo del ejercicio 
            <strong>Marker Based Visual Loc</strong>.
        </p>

        <p>
            A continuación se muestra cómo se ve inicialmente el ejercicio 
            <strong>Marker Based Visual Loc</strong> al lanzar el Docker de RoboticsAcademy 
            antes de realizar cualquier cambio en el código:
        </p>
        <div style="place-items: center">
            <img src="images/semana02/markervisualloc_original_world.png" alt="Original World" class="screenshot">
        </div>

        <p>
            El único cambio que he realizado ha sido en el fichero 
            <strong>RoboticsInfrastructure/Launchers/marker_visual_loc.launch.py</strong> 
            en la siguiente línea:
        </p>
        <pre><code># ANTES (MUNDO ORIGINAL)<br>world_file_name = "marker_visual_loc.world"<br><br># DESPUÉS (MUNDO NUEVO)<br>world_file_name = "laser_mapping.world"</code></pre>

        <p>
            Una vez realizado este cambio, he hecho commit y push en una nueva rama que he creado
            y publicado llamada <strong>test-aleon2020</strong>. Es importante hacer esto 
            siempre para evitar así cualquier tipo de conflicto con la rama principal.
        </p>

        <p>
            Como los cambios se han realizado en un fichero que se encuentra dentro de 
            RoboticsInfrastructure, es obligatorio generar un nuevo RADI. Para ello, se deben 
            ejecutar los siguientes comandos en la terminal:
        </p>
        <pre><code>cd scripts/RADI/</code></pre>
        <pre><code>./build.sh -i test-aleon2020</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: Cada vez que se genera un nuevo RADI no se borra el 
            anterior, por lo que el espacio disponible en disco se irá llenando y llenando 
            cada vez que se genere un nuevo RADI hasta que no quede espacio disponible en disco.
            Para evitar que esto ocurra, se debe ejecutar el siguiente comando en la terminal, 
            el cual se encargará de borrar todo el espacio de memoria que se ha ido llenando por 
            cada RADI generado:
        </p>
        <pre><code>docker system prune -af</code></pre>

        <p>
            <strong>IMPORTANTE</strong>: Si es la primera vez que se ejecuta este script, el 
            tiempo que tardará en ejecutarse por completo será considerablemente largo, ya que 
            debe configurar todo el entorno. Si es la primera vez que se ejecuta tardará unos 
            35-45 minutos, de lo contrario, tardará unos 2-3 minutos.
        </p>

        <p>
            Una vez finalizada la ejecución del script <strong>build.sh</strong>, se debe 
            regresar al repositorio principal:
        </p>
        <pre><code>cd ../..</code></pre>

        <p>
            Pero antes de ejecutar el script <strong>develop_academy.sh</strong>, hay que 
            modificar la siguiente línea del fichero 
            <strong>RoboticsAcademy/compose_cfg/dev_humble_cpu.yaml</strong>:
        </p>
        <pre><code># ANTES<br>  robotics-academy:<br>    image: jderobot/robotics-academy:latest<br><br># DESPUÉS<br>  robotics-academy:<br>    image: jderobot/robotics-academy:test</code></pre>

        <p>
            Con este cambio ya realizado, ya se puede lanzar el script 
            <strong>develop_academy.sh</strong>:
        </p>
        <pre><code>./scripts/develop_academy.sh</code></pre>

        <p>
            Y por último, sólo quedaría acceder a la dirección web `http://0.0.0.0:7164/` que 
            aparece en la terminal al ejecutar el comando anterior para poder entrar a Unibotics 
            en local y verificar que los cambios se han realizado correctamente.
        </p>

        <p>
            A continuación se muestra cómo se ve el ejercicio 
            <strong>Marker Based Visual Loc</strong> al lanzar el Docker de RoboticsAcademy 
            con todos estos cambios realizados en el código:
        </p>
        <div style="place-items: center">
            <img src="images/semana02/markervisualloc_new_world.png" alt="New World" class="screenshot">
        </div>
    </div>

    <!-- Entrada de blog (semana 03) -->
    <div id="entry-3" class="entry">
        <p class="date">SEMANA 03: 06-10-2025 al 10-10-2025</p>

        <h1>
            Migración del ejercicio Obstacle Avoidance a Gazebo Harmonic
        </h1>

        <p>
            Una vez realizado este primer ejercicio de calentamiento para irme familiarizando
            con el código de RoboticsInfrastructure, se me ha pedido realizar la migración 
            completa de Gazebo 11 a Gazebo Harmonic del ejercicio 
            <strong>Obstacle Avoidance</strong>, que introduce de forma práctica la navegación 
            local mediante el uso de campos de fuerza virtuales (VFF, Virtual Force Fields).
        </p>

        <div style="place-items: center">
            <img src="images/semana03/obstacle_avoidance_exercise.png" alt="Obstacle Avoidance Exercise" class="screenshot">
        </div>
        <p><strong>ENLACE AL ENUNCIADO DEL EJERCICIO</strong>: <a href="https://jderobot.github.io/RoboticsAcademy/exercises/AutonomousCars/obstacle_avoidance">https://jderobot.github.io/RoboticsAcademy/exercises/AutonomousCars/obstacle_avoidance</a></p>

        <p>
            A continuación, se encuentran todos los ficheros que se han modificado y/o creado
            (y de qué forma) para poder llevar a cabo la migración completa de este ejercicio
            de Gazebo 11 a Gazebo Harmonic:
        </p>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/f1/models/f1_result_laser_no_cam/model.sdf
        </strong></p>
        <p>
            En este fichero se han modificado las partes correspondientes a las etiquetas
            &lt;plugin&gt; y &lt;sensor&gt;, donde el plugin pasa de estar declarado dentro 
            del sensor a integrarse en él. Además, es importante añadir al final de la nueva 
            versión los plugins correspondientes al <strong>diff-drive-system</strong> y al 
            <strong>odometry-publisher-system</strong>:
        </p>
        <pre><code>&lt;?xml version='1.0'?&gt;<br>&lt;sdf version="1.9"&gt;<br>&lt;model name="f1_renault"&gt;<br>  &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;<br>  &lt;static&gt;false&lt;/static&gt;<br><br>    &lt;link name="f1"&gt;<br>      &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;<br>      &lt;inertial&gt;<br>        &lt;mass&gt;10&lt;/mass&gt;<br>        &lt;inertia&gt;<br>          &lt;ixx&gt;1&lt;/ixx&gt;<br>          &lt;ixy&gt;0.0&lt;/ixy&gt;<br>          &lt;iyy&gt;1&lt;/iyy&gt;<br>          &lt;ixz&gt;0.0&lt;/ixz&gt;<br>          &lt;iyz&gt;0.0&lt;/iyz&gt;<br>          &lt;izz&gt;1.0&lt;/izz&gt;<br>        &lt;/inertia&gt;<br>      &lt;/inertial&gt;<br>      &lt;collision name="collision"&gt;<br>        &lt;geometry&gt;<br>          &lt;mesh&gt;<br>            &lt;uri&gt;model://f1_renault_laser_no_cam/Renault/Car.obj&lt;/uri&gt;<br>            &lt;scale&gt;0.2 0.2 0.2&lt;/scale&gt;<br>          &lt;/mesh&gt;<br>        &lt;/geometry&gt;<br>      &lt;/collision&gt;<br>      &lt;visual name="visual"&gt;<br>        &lt;geometry&gt;<br>          &lt;mesh&gt;<br>            &lt;uri&gt;model://f1_renault_laser_no_cam/Renault/Car.obj&lt;/uri&gt;<br>            &lt;scale&gt;0.2 0.2 0.2&lt;/scale&gt;<br>          &lt;/mesh&gt;<br>        &lt;/geometry&gt;<br>      &lt;/visual&gt;<br>    &lt;/link&gt;<br><br>    &lt;link name='laser_body'&gt;<br>      &lt;pose&gt;0.500000 0.000000 0.072000 0.000000 0.000000 0.00000&lt;/pose&gt;<br>      &lt;visual name="visual_laser"&gt;<br>        &lt;geometry&gt;<br>          &lt;mesh&gt;<br>            &lt;uri&gt;model://f1_renault_laser_no_cam/meshes/hokuyo.dae&lt;/uri&gt;<br>          &lt;/mesh&gt;<br>        &lt;/geometry&gt;<br>      &lt;/visual&gt;<br><br>      &lt;sensor name="laser" type="gpu_lidar"&gt;<br>        &lt;always_on&gt;1&lt;/always_on&gt;<br>        &lt;visualize&gt;1&lt;/visualize&gt;<br>        &lt;pose&gt;0.500000 0.000000 0.072000 0.000000 0.000000 0.00000&lt;/pose&gt;<br>        &lt;update_rate&gt;20.000000&lt;/update_rate&gt;<br>        &lt;topic&gt;f1/laser/scan&lt;/topic&gt;<br>        &lt;frame&gt;base_scan&lt;/frame&gt;<br>        &lt;lidar&gt;<br>          &lt;scan&gt;<br>            &lt;horizontal&gt;<br>              &lt;samples&gt;180&lt;/samples&gt;<br>              &lt;resolution&gt;1.000000&lt;/resolution&gt;<br>              &lt;min_angle&gt;-1.570000&lt;/min_angle&gt;<br>              &lt;max_angle&gt;1.570000&lt;/max_angle&gt;<br>            &lt;/horizontal&gt;<br>          &lt;/scan&gt;<br>          &lt;range&gt;<br>            &lt;min&gt;0.080000&lt;/min&gt;<br>            &lt;max&gt;10.000000&lt;/max&gt;<br>            &lt;resolution&gt;0.010000&lt;/resolution&gt;<br>          &lt;/range&gt;<br>        &lt;/lidar&gt;<br>      &lt;/sensor&gt;<br>    &lt;/link&gt;<br><br>    &lt;!-- &lt;velocity_decay&gt;<br>      &lt;linear&gt;0.000000&lt;/linear&gt;<br>      &lt;angular&gt;0.000000&lt;/angular&gt;<br>    &lt;/velocity_decay&gt;<br>    &lt;self_collide&gt;0&lt;/self_collide&gt;<br>    &lt;kinematic&gt;0&lt;/kinematic&gt;<br>  &lt;/link&gt; --&gt;<br><br>    &lt;joint type="fixed" name="laser_fix"&gt;<br>      &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;<br>      &lt;child&gt;laser_body&lt;/child&gt;<br>      &lt;parent&gt;f1&lt;/parent&gt;<br>      &lt;!-- &lt;axis&gt;<br>        &lt;xyz&gt;0 0 0&lt;/xyz&gt;<br>    &lt;/axis&gt; --&gt;<br>    &lt;/joint&gt;<br><br>    &lt;plugin filename="gz-sim-velocity-control-system" name="gz::sim::systems::VelocityControl"&gt;<br>      &lt;topic&gt;/F1ROS/cmd_vel&lt;/topic&gt;<br>    &lt;/plugin&gt;<br><br>    &lt;plugin filename="gz-sim-odometry-publisher-system" name="gz::sim::systems::OdometryPublisher"&gt;<br>      &lt;odom_frame&gt;odom&lt;/odom_frame&gt;<br>      &lt;robot_base_frame&gt;xf1&lt;/robot_base_frame&gt;<br>      &lt;odom_publish_frequency&gt;20.0&lt;/odom_publish_frequency&gt;<br>      &lt;odom_topic&gt;F1ROS/odom&lt;/odom_topic&gt;<br>      &lt;dimensions&gt;3&lt;/dimensions&gt;<br>    &lt;/plugin&gt;<br><br>&lt;/model&gt;<br>&lt;/sdf&gt;</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/f1/params/f1_result_laser_no_cam.yaml
        </strong></p>
        <p>
            Este fichero se crea de cero en la ruta especificada, aunque se puede coger 
            cualquier fichero del tipo <strong>robot_params.yaml</strong> como referencia. 
            En este caso, sólo se añaden los topics correspondientes al publicador y al 
            subscriptor del plugin del diff-drive-system y aquellos relativos al publicador 
            del plugin del láser:
        </p>
        <pre><code># gz topic published by DiffDrive plugin<br>- ros_topic_name: "odom"<br>  gz_topic_name: "F1ROS/odom"<br>  ros_type_name: "nav_msgs/msg/Odometry"<br>  gz_type_name: "gz.msgs.Odometry"<br>  direction: GZ_TO_ROS<br><br># gz topic subscribed to by DiffDrive plugin<br>- ros_topic_name: "cmd_vel"<br>  gz_topic_name: "/F1ROS/cmd_vel"<br>  ros_type_name: "geometry_msgs/msg/Twist"<br>  gz_type_name: "gz.msgs.Twist"<br>  direction: ROS_TO_GZ<br><br># gz topic published by Sensors plugin (LIDAR)<br>- ros_topic_name: "f1/laser/scan"<br>  gz_topic_name: "f1/laser/scan"<br>  ros_type_name: "sensor_msgs/msg/LaserScan"<br>  gz_type_name: "gz.msgs.LaserScan"<br>  direction: GZ_TO_ROS</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/CMakeLists.txt
        </strong></p>
        <p>
            En este caso, la única modificación realizada en este fichero es la 
            adición de la línea <strong>f1/params</strong> para que el fichero que se acaba de 
            crear (<strong>f1_result_laser_no_cam.yaml</strong>) se tenga en cuenta a la hora de 
            lanzar el Docker:
        </p>
        <pre><code># GAZEBO 11<br><br>install(<br>  DIRECTORY<br>    ...<br>    # F1<br>    f1/models<br>    f1/launch<br>    f1/worlds<br>    ...<br>  DESTINATION share/${PROJECT_NAME})</code></pre>
        <pre><code># GAZEBO HARMONIC<br><br>install(<br>  DIRECTORY<br>    ...<br>    # F1<br>    f1/models<br>    f1/launch<br>    f1/worlds<br>    f1/params<br>    ...<br>  DESTINATION share/${PROJECT_NAME})</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/Launchers/obstacle_avoidance/spawn_robot.launch.py
        </strong></p>
        <p>
            Una vez creado el directorio <strong>obstacle_avoidance/</strong>, y a su vez dentro 
            de él el fichero <strong>spawn_robot.launch.py</strong>, lo único que habría que 
            hacer es coger cualquier fichero con el mismo nombre de otro ejercicio que ya esté 
            migrado a Gazebo Harmonic, copiar su contenido y sólamente habría que comentar todo 
            lo relativo a las variables <strong>start_gazebo_ros_image_bridge_cmd</strong> y 
            <strong>start_gazebo_ros_depth_bridge_cmd</strong>, y lo más importante, modificar 
            el nombre del fichero que se le pasa como argumento a bridge_params (en este caso, 
            <strong>f1_renault_laser_no_cam.yaml</strong>):
        </p>
        <pre><code># Copyright 2019 Open Source Robotics Foundation, Inc.<br>#<br># Licensed under the Apache License, Version 2.0 (the "License");<br># you may not use this file except in compliance with the License.<br># You may obtain a copy of the License at<br>#<br>#     http://www.apache.org/licenses/LICENSE-2.0<br>#<br># Unless required by applicable law or agreed to in writing, software<br># distributed under the License is distributed on an "AS IS" BASIS,<br># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br># See the License for the specific language governing permissions and<br># limitations under the License.<br><br>import os<br><br>from ament_index_python.packages import get_package_share_directory<br>from launch import LaunchDescription<br>from launch.actions import DeclareLaunchArgument<br>from launch.substitutions import LaunchConfiguration<br>from launch_ros.actions import Node<br><br><br>def generate_launch_description():<br>    # Get the urdf file<br>    model_folder = "f1_renault_laser_no_cam"<br>    urdf_path = os.path.join(<br>        get_package_share_directory("custom_robots"),<br>        "models",<br>        model_folder,<br>        "model.sdf",<br>    )<br><br>    # Launch configuration variables specific to simulation<br>    # x_pose = LaunchConfiguration('x_pose', default='1.0')<br>    # y_pose = LaunchConfiguration('y_pose', default='-1.5')<br>    # z_pose = LaunchConfiguration('z_pose', default='7.1')<br><br>    # Declare the launch arguments<br>    # declare_x_position_cmd = DeclareLaunchArgument(<br>    #     'x_pose', default_value='1.0',<br>    #     description='Specify namespace of the robot')<br><br>    # declare_y_position_cmd = DeclareLaunchArgument(<br>    #     'y_pose', default_value='-1.5',<br>    #     description='Specify namespace of the robot')<br><br>    # declare_z_position_cmd = DeclareLaunchArgument(<br>    #     'z_pose', default_value='7.1',<br>    #     description='Specify namespace of the robot')<br><br>    # start_gazebo_ros_spawner_cmd = Node(<br>    #     package='ros_gz_sim',<br>    #     executable='create',<br>    #     arguments=[<br>    #         '-name', 'waffle',<br>    #         '-file', urdf_path,<br>    #         '-x', x_pose,<br>    #         '-y', y_pose,<br>    #         '-z', z_pose<br>    #     ],<br>    #     output='screen',<br>    # )<br><br>    bridge_params = os.path.join(<br>        get_package_share_directory("custom_robots"), "params", "f1_renault_laser_no_cam.yaml"<br>    )<br><br>    start_gazebo_ros_bridge_cmd = Node(<br>        package="ros_gz_bridge",<br>        executable="parameter_bridge",<br>        arguments=[<br>            "--ros-args",<br>            "-p",<br>            f"config_file:={bridge_params}",<br>        ],<br>        output="screen",<br>    )<br><br>    # start_gazebo_ros_image_bridge_cmd = Node(<br>    #     package="ros_gz_image",<br>    #     executable="image_bridge",<br>    #     arguments=["/turtlebot3/camera/image_raw"],<br>    #     output="screen",<br>    # )<br><br>    # start_gazebo_ros_depth_bridge_cmd = Node(<br>    #     package="ros_gz_image",<br>    #     executable="image_bridge",<br>    #     arguments=["/turtlebot3/camera/depth"],<br>    #     output="screen",<br>    # )<br><br>    ld = LaunchDescription()<br><br>    # Declare the launch options<br>    # ld.add_action(declare_x_position_cmd)<br>    # ld.add_action(declare_y_position_cmd)<br>    # ld.add_action(declare_z_position_cmd)<br><br>    # Add any conditioned actions<br>    # ld.add_action(start_gazebo_ros_spawner_cmd)<br>    ld.add_action(start_gazebo_ros_bridge_cmd)<br>    # ld.add_action(start_gazebo_ros_image_bridge_cmd)<br>    # ld.add_action(start_gazebo_ros_depth_bridge_cmd)<br><br>    return ld</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/Launchers/simple_circuit_obstacles_followingcam.launch.py
        </strong></p>
        <p>
            Para este fichero, lo único que habría que hacer es un Ctrl+C Ctrl+V de 
            cualquier fichero con el mismo formato de nombre que ya haya sido migrado a Gazebo 
            Harmonic y modificar únicamente las líneas correspondientes a las 
            variables <strong>robot_launch_dir</strong> y <strong>world_file_name</strong>, 
            correspondientes a las rutas en las que se encuentran el directorio que almacena el 
            fichero <strong>spawn_robot.launch.py</strong> y el fichero del mundo que utiliza 
            este ejercicio.
        </p>
        <pre><code>import os<br><br>from ament_index_python.packages import get_package_share_directory<br><br>from launch import LaunchDescription<br>from launch.actions import (<br>    DeclareLaunchArgument,<br>    IncludeLaunchDescription,<br>    SetEnvironmentVariable,<br>    AppendEnvironmentVariable,<br>)<br>from launch.launch_description_sources import PythonLaunchDescriptionSource<br>from launch.substitutions import LaunchConfiguration, Command<br>from launch_ros.actions import Node<br>from launch.substitutions import LaunchConfiguration<br>from launch_ros.actions import Node<br><br><br>def generate_launch_description():<br><br>    x = LaunchConfiguration("x")<br>    y = LaunchConfiguration("y")<br>    z = LaunchConfiguration("z")<br>    roll = LaunchConfiguration("R")<br>    pitch = LaunchConfiguration("P")<br>    yaw = LaunchConfiguration("Y")<br><br>    package_dir = get_package_share_directory("custom_robots")<br>    ros_gz_sim = get_package_share_directory("ros_gz_sim")<br><br>    gazebo_models_path = os.path.join(package_dir, "models")<br><br>    robot_launch_dir = "/opt/jderobot/Launchers/obstacle_avoidance"<br><br>    use_sim_time = LaunchConfiguration("use_sim_time", default="true")<br>    x_pose = LaunchConfiguration("x_pose", default="1.0")<br>    y_pose = LaunchConfiguration("y_pose", default="-1.5")<br>    z_pose = LaunchConfiguration("z_pose", default="7.1")<br>    world_file_name = "simple_circuit_obstacles_followingcam.world"<br>    worlds_dir = "/opt/jderobot/Worlds"<br>    world_path = os.path.join(worlds_dir, world_file_name)<br><br>    gazebo_server = IncludeLaunchDescription(<br>        PythonLaunchDescriptionSource(<br>            os.path.join(ros_gz_sim, "launch", "gz_sim.launch.py")<br>        ),<br>        launch_arguments={<br>            "gz_args": ["-r -s -v4 ", world_path],<br>            "on_exit_shutdown": "true",<br>        }.items(),<br>    )<br><br>    declare_x_cmd = DeclareLaunchArgument("x", default_value="1.0")<br><br>    declare_y_cmd = DeclareLaunchArgument("y", default_value="-1.5")<br><br>    declare_z_cmd = DeclareLaunchArgument("z", default_value="7.1")<br><br>    declare_roll_cmd = DeclareLaunchArgument("R", default_value="0.0")<br><br>    declare_pitch_cmd = DeclareLaunchArgument("P", default_value="0.0")<br><br>    declare_yaw_cmd = DeclareLaunchArgument("Y", default_value="1.57079")<br><br>    # robot_state_publisher_cmd = IncludeLaunchDescription(<br>    #     PythonLaunchDescriptionSource(<br>    #         os.path.join(robot_launch_dir, "robot_state_publisher.launch.py")<br>    #     ),<br>    #     launch_arguments={"use_sim_time": use_sim_time}.items(),<br>    # )<br><br>    spawn_robot_cmd = IncludeLaunchDescription(<br>        PythonLaunchDescriptionSource(<br>            os.path.join(robot_launch_dir, "spawn_robot.launch.py")<br>        ),<br>        launch_arguments={"x_pose": x_pose, "y_pose": y_pose, "z_pose": z_pose}.items(),<br>    )<br><br>    world_entity_cmd = Node(<br>        package="ros_gz_sim",<br>        executable="create",<br>        arguments=["-name", "world", "-file", world_path],<br>        output="screen",<br>    )<br><br>    ld = LaunchDescription()<br><br>    ld.add_action(SetEnvironmentVariable("GZ_SIM_RESOURCE_PATH", gazebo_models_path))<br>    set_env_vars_resources = AppendEnvironmentVariable(<br>        "GZ_SIM_RESOURCE_PATH", os.path.join(package_dir, "models")<br>    )<br>    ld.add_action(set_env_vars_resources)<br>    ld.add_action(gazebo_server)<br>    # ld.add_action(gazebo_client)<br>    ld.add_action(declare_x_cmd)<br>    ld.add_action(declare_y_cmd)<br>    ld.add_action(declare_z_cmd)<br>    ld.add_action(declare_roll_cmd)<br>    ld.add_action(declare_pitch_cmd)<br>    ld.add_action(declare_yaw_cmd)<br>    ld.add_action(world_entity_cmd)<br>    # ld.add_action(robot_state_publisher_cmd)<br>    ld.add_action(spawn_robot_cmd)<br><br>    return ld</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: En caso de que no se haya creado dentro del directorio 
            <strong>obstacle_avoidance/</strong> el fichero 
            <strong>robot_state_publisher.launch.py</strong>, es obligatorio comentar 
            y/o eliminar del código todo lo relacionado con la variable 
            <strong>robot_state_publisher_cmd</strong>.
        </p>

        <p><strong>
            FICHERO RoboticsInfrastructure/Worlds/simple_circuit_obstacles_followingcam.world
        </strong></p>
        <p>
            En este fichero, lo único que habría que realizar es un Ctrl+C Ctrl+V de 
            cualquier fichero con el mismo formato de nombre que ya haya sido migrado a Gazebo 
            Harmonic y sustituir todas aquellos flags &lt;include&gt; de la versión antigua por 
            aquellos que aparezcan en la versión nueva.
        </p>
        <pre><code>&lt;?xml version="1.0" ?&gt;<br><br>&lt;sdf version="1.9"&gt;<br>  &lt;world name="default"&gt;<br><br>    &lt;plugin<br>      filename="gz-sim-physics-system"<br>      name="gz::sim::systems::Physics"&gt;<br>    &lt;/plugin&gt;<br>    &lt;plugin<br>      filename="gz-sim-scene-broadcaster-system"<br>      name="gz::sim::systems::SceneBroadcaster"&gt;<br>    &lt;/plugin&gt;<br>    &lt;plugin<br>      filename="gz-sim-user-commands-system"<br>      name="gz::sim::systems::UserCommands"&gt;<br>    &lt;/plugin&gt;<br>    &lt;plugin<br>      filename="gz-sim-sensors-system"<br>      name="gz::sim::systems::Sensors"&gt;<br>      &lt;render_engine&gt;ogre2&lt;/render_engine&gt;<br>    &lt;/plugin&gt;<br><br>    &lt;scene&gt;<br>      &lt;shadows&gt;false&lt;/shadows&gt;<br>    &lt;/scene&gt;<br><br>    &lt;light type="directional" name="sun"&gt;<br>      &lt;!-- &lt;cast_shadows&gt;true&lt;/cast_shadows&gt; --&gt;<br>      &lt;pose&gt;0 0 20 -1.3 0 0.5&lt;/pose&gt;<br>      &lt;diffuse&gt;0.8 0.8 0.8 1&lt;/diffuse&gt;<br>      &lt;specular&gt;0.01 0.01 0.01 1&lt;/specular&gt;<br>      &lt;intensity&gt;2&lt;/intensity&gt;<br>      &lt;visualize&gt;false&lt;/visualize&gt;<br>    &lt;/light&gt;<br>    &lt;light type="point" name="point_light"&gt;<br>      &lt;pose&gt;0.73 0.09 8.77 0 0 0&lt;/pose&gt;<br>      &lt;diffuse&gt;1 1 1 1&lt;/diffuse&gt;<br>      &lt;specular&gt;.01 .01 .01 1&lt;/specular&gt;<br>      &lt;attenuation&gt;<br>        &lt;range&gt;20&lt;/range&gt;<br>        &lt;linear&gt;0.2&lt;/linear&gt;<br>        &lt;constant&gt;0.8&lt;/constant&gt;<br>        &lt;quadratic&gt;0.01&lt;/quadratic&gt;<br>      &lt;/attenuation&gt;<br>      &lt;!-- &lt;cast_shadows&gt;true&lt;/cast_shadows&gt; --&gt;<br>      &lt;visualize&gt;false&lt;/visualize&gt;<br>    &lt;/light&gt;<br>    &lt;light type="point" name="point_light_01"&gt;<br>      &lt;pose&gt;3.482 -4.28 8.87 0 0 0&lt;/pose&gt;<br>      &lt;diffuse&gt;1 1 1 1&lt;/diffuse&gt;<br>      &lt;specular&gt;0.01 0.01 0.01 1&lt;/specular&gt;<br>      &lt;attenuation&gt;<br>        &lt;range&gt;10&lt;/range&gt;<br>        &lt;linear&gt;0.5&lt;/linear&gt;<br>        &lt;constant&gt;0.8&lt;/constant&gt;<br>        &lt;quadratic&gt;0.001&lt;/quadratic&gt;<br>      &lt;/attenuation&gt;<br>      &lt;cast_shadows&gt;false&lt;/cast_shadows&gt;<br>      &lt;visualize&gt;false&lt;/visualize&gt;<br>    &lt;/light&gt;<br>    &lt;light type="point" name="point_light_02"&gt;<br>      &lt;pose&gt;0.13 0.46 11.60 0 0 0&lt;/pose&gt;<br>      &lt;diffuse&gt;1 1 1 1&lt;/diffuse&gt;<br>      &lt;specular&gt;0.01 0.01 0.01 1&lt;/specular&gt;<br>      &lt;attenuation&gt;<br>        &lt;range&gt;10&lt;/range&gt;<br>        &lt;linear&gt;0.2&lt;/linear&gt;<br>        &lt;constant&gt;0.5&lt;/constant&gt;<br>        &lt;quadratic&gt;0.001&lt;/quadratic&gt;<br>      &lt;/attenuation&gt;<br>      &lt;cast_shadows&gt;false&lt;/cast_shadows&gt;<br>      &lt;visualize&gt;false&lt;/visualize&gt;<br>    &lt;/light&gt;<br>    &lt;light type="point" name="point_light_03"&gt;<br>      &lt;pose&gt;4.27 -1.27 11.21 0 0 0&lt;/pose&gt;<br>      &lt;diffuse&gt;1 1 1 1&lt;/diffuse&gt;<br>      &lt;specular&gt;0.01 0.01 0.01 1&lt;/specular&gt;<br>      &lt;attenuation&gt;<br>        &lt;range&gt;10&lt;/range&gt;<br>        &lt;linear&gt;0.5&lt;/linear&gt;<br>        &lt;constant&gt;0.8&lt;/constant&gt;<br>        &lt;quadratic&gt;0.001&lt;/quadratic&gt;<br>      &lt;/attenuation&gt;<br>      &lt;cast_shadows&gt;false&lt;/cast_shadows&gt;<br>      &lt;visualize&gt;false&lt;/visualize&gt;<br>    &lt;/light&gt;<br>    &lt;light type="point" name="point_light_04"&gt;<br>      &lt;pose&gt;-0.31 -3.78 8.61 0 0 0&lt;/pose&gt;<br>      &lt;diffuse&gt;1 1 1 1&lt;/diffuse&gt;<br>      &lt;specular&gt;.01 .01 .01 1&lt;/specular&gt;<br>      &lt;attenuation&gt;<br>        &lt;range&gt;10&lt;/range&gt;<br>        &lt;linear&gt;0.5&lt;/linear&gt;<br>        &lt;constant&gt;0.8&lt;/constant&gt;<br>        &lt;quadratic&gt;0.001&lt;/quadratic&gt;<br>      &lt;/attenuation&gt;<br>      &lt;cast_shadows&gt;false&lt;/cast_shadows&gt;<br>      &lt;visualize&gt;false&lt;/visualize&gt;<br>    &lt;/light&gt;<br><br>    &lt;model name='ground_plane'&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>      &lt;link name='link'&gt;<br>        &lt;collision name='collision'&gt;<br>          &lt;geometry&gt;<br>            &lt;plane&gt;<br>              &lt;normal&gt;0.0 0.0 1&lt;/normal&gt;<br>              &lt;size&gt;1000 1000&lt;/size&gt;<br>            &lt;/plane&gt;<br>          &lt;/geometry&gt;<br>        &lt;/collision&gt;<br>      &lt;/link&gt;<br>      &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;<br>    &lt;/model&gt;<br><br>    &lt;include&gt;<br>      &lt;uri&gt;model://simple_circuit&lt;/uri&gt;<br>      &lt;pose&gt;-53.46 11.50 0 0 0 0&lt;/pose&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_renault_laser_no_cam&lt;/uri&gt;<br>      &lt;pose&gt;0.04 0.68 0 0 0 -1.57&lt;/pose&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_1&lt;/name&gt;<br>      &lt;pose&gt;-0.1 -33 0 0 0 0&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_2&lt;/name&gt;<br>      &lt;pose&gt;-7 -40 0 0 0 -1.67&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_3&lt;/name&gt;<br>      &lt;pose&gt;-13.2 -18.8 0 0 0 -3&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_4&lt;/name&gt;<br>      &lt;pose&gt;-40 -11.5 0 0 0 -1.57&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_5&lt;/name&gt;<br>      &lt;pose&gt;-66.83 -34.15 0 0 0 -1.03&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_6&lt;/name&gt;<br>      &lt;pose&gt;-70.8 -34.2 0 0 0 -1.33&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_7&lt;/name&gt;<br>      &lt;pose&gt;-103 14.6 0 0 0 2.47&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_8&lt;/name&gt;<br>      &lt;pose&gt;-52.76 42.3 0 0 0 2.15&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_9&lt;/name&gt;<br>      &lt;pose&gt;-33.4 57.3 0 0 0 0&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_10&lt;/name&gt;<br>      &lt;pose&gt;-3.5 59 0 0 0 0.785&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_11&lt;/name&gt;<br>      &lt;pose&gt;1 26.2 0 0 0 0&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br>    &lt;include&gt;<br>      &lt;uri&gt;model://f1_dummy_harmonic&lt;/uri&gt;<br>      &lt;name&gt;f1_dummy_12&lt;/name&gt;<br>      &lt;pose&gt;-1 24.5 0 0 0 0&lt;/pose&gt;<br>      &lt;static&gt;true&lt;/static&gt;<br>    &lt;/include&gt;<br><br>  &lt;/world&gt;<br>&lt;/sdf&gt;</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/database/universes.sql
        </strong></p>
        <p>
            Este es uno de los cambios más sencillos de realizar en todo el proceso de migración.
            Lo único que habría que hacer es identificar el ejercicio que se quiere migrar de 
            Gazebo 11 a Gazebo Harmonic (en este caso, Obstacle Avoidance) y cambiar el valor de
            la columna <strong>type</strong> de <strong>gazebo</strong> a <strong>gz</strong>:
        </p>
        <pre><code># GAZEBO 11<br>19	Obstacle Avoidance Default	/opt/jderobot/Launchers/simple_circuit_obstacles_followingcam.launch.py	None	ROS2	gazebo	{0.0,0.0,0.0,0.0,0.0,0.0}</code></pre>
        <pre><code># GAZEBO HARMONIC<br>19	Obstacle Avoidance Default	/opt/jderobot/Launchers/simple_circuit_obstacles_followingcam.launch.py	None	ROS2	gz	{0.0,0.0,0.0,0.0,0.0,0.0}</code></pre>

        <p>
            Una vez realizados todos estos cambios en todos los ficheros mencionados, 
            he hecho commit y push en una nueva rama que he creado y publicado llamada 
            <strong>obstacle-avoidance-harmonic</strong>. Es importante hacer esto siempre para 
            así evitar cualquier tipo de conflicto con la rama principal.
        </p>

        <p>
            Como todos los cambios se han realizado en ficheros que se encuentran dentro de 
            RoboticsInfrastructure, es obligatorio generar un nuevo RADI. Para ello, se deben 
            ejecutar los siguientes comandos en la terminal:
        </p>
        <pre><code>cd scripts/RADI/</code></pre>
        <pre><code>./build.sh -i obstacle-avoidance-harmonic</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: Cada vez que se genera un nuevo RADI no se borra el 
            anterior, por lo que el espacio disponible en disco se irá llenando y llenando 
            cada vez que se genere un nuevo RADI hasta que no quede espacio disponible en disco.
            Para evitar que esto ocurra, se debe ejecutar el siguiente comando en la terminal, 
            el cual se encargará de borrar todo el espacio de memoria que se ha ido llenando por 
            cada RADI generado:
        </p>
        <pre><code>docker system prune -af</code></pre>

        <p>
            Una vez finalizada la ejecución del script <strong>build.sh</strong>, se debe 
            regresar al repositorio principal:
        </p>
        <pre><code>cd ../..</code></pre>

        <p>
            Pero antes de ejecutar el script <strong>develop_academy.sh</strong>, hay que 
            modificar la siguiente línea del fichero 
            <strong>RoboticsAcademy/compose_cfg/dev_humble_cpu.yaml</strong>:
        </p>
        <pre><code># ANTES<br>  robotics-academy:<br>    image: jderobot/robotics-academy:latest<br><br># DESPUÉS<br>  robotics-academy:<br>    image: jderobot/robotics-academy:test</code></pre>

        <p>
            Con este cambio ya realizado, ya se puede lanzar el script 
            <strong>develop_academy.sh</strong>:
        </p>
        <pre><code>./scripts/develop_academy.sh</code></pre>

        <p>
            Y por último, sólo quedaría acceder a la dirección web `http://0.0.0.0:7164/` que 
            aparece en la terminal al ejecutar el comando anterior para poder entrar a Unibotics 
            en local y verificar que los cambios se han realizado correctamente.
        </p>

        <p>
            A continuación se muestra cómo se ve el ejercicio <strong>Obstacle Avoidance</strong> 
            al lanzar el Docker de RoboticsAcademy con todos estos cambios realizados:
        </p>
        <div style="place-items: center">
            <img src="images/semana03/obstacle_avoidance_image.png" alt="Obstacle Avoidance Image" class="screenshot">
        </div>
        <p>
            Además, para verificar que tanto el escenario como el coche han sido migrados 
            correctamente, se muestra una pequeña animación del coche moviéndose en línea 
            recta para verificar que todo el proceso se ha realizado correctamente:
        </p>
        <video width="960" height="540" controls style="display: block; margin: 0 auto;" poster="images/semana03/obstacle_avoidance_image.png">
            <source src="videos/semana03/obstacle_avoidance_video.mp4" type="video/mp4">
        </video>
    </div>
    
    <!-- Entrada de blog (semana 04) -->
    <div id="entry-4" class="entry">
        <p class="date">SEMANA 04: 13-10-2025 al 17-10-2025</p>

        <h1>
            Migración del ejercicio Global Navigation a Gazebo Harmonic
        </h1>

        <p>
            Con el ejercicio de Obstacle Avoidance ya migrado por completo a Gazebo Harmonic, 
            se me ha pedido realizar la migración completa de Gazebo 11 a Gazebo Harmonic de un 
            segundo ejercicio, en este caso, <strong>Global Navigation</strong>, que introduce 
            de forma práctica la navegación global mediante el uso y la implementación de la 
            lógica del algoritmo de planificación de ruta del gradiente (GPP, Gradient Path 
            Planning).
        </p>

        <div style="place-items: center">
            <img src="images/semana04/global_navigation_exercise.png" alt="Global Navigation Exercise" class="screenshot">
        </div>
        <p><strong>ENLACE AL ENUNCIADO DEL EJERCICIO</strong>: <a href="https://jderobot.github.io/RoboticsAcademy/exercises/AutonomousCars/global_navigation/">https://jderobot.github.io/RoboticsAcademy/exercises/AutonomousCars/global_navigation/</a></p>

        <p>
            A continuación, se encuentran todos los ficheros que se han modificado y/o creado
            (y de qué forma) para poder llevar a cabo la migración completa de este ejercicio
            de Gazebo 11 a Gazebo Harmonic:
        </p>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/taxi_navigator/models/taxi_holo_ROS_harmonic/model.sdf
        </strong></p>
        <p>
            En este caso, no ha sido necesario llevar a cabo ninguna modificación en este 
            fichero, ya que el coche utilizado para esta versión ya se encuentra migrado a 
            Gazebo Harmonic:
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/taxi_navigator/params/taxi_holo_ROS_harmonic.yaml
        </strong></p>
        <p>
            Este fichero se crea de cero en la ruta especificada, aunque se puede coger 
            cualquier fichero del tipo <strong>robot_params.yaml</strong> como referencia. 
            En este caso, se añaden los topics correspondientes al plugin subscriptor del 
            DiffDrive, y los plugin publicadores del DiffDrive, del sensor láser LIDAR y de 
            la cámara.
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/CMakeLists.txt
        </strong></p>
        <p>
            En este caso, la única modificación realizada en este fichero es la 
            adición de las líneas <strong>taxi_navigator/launch</strong>,
            <strong>taxi_navigator/params</strong> y <strong>taxi_navigator/worlds</strong>, 
            para que el fichero que se acaba de crear (<strong>taxi_holo_ROS_harmonic.yaml</strong>),
            se tenga en cuenta a la hora de lanzar el Docker:
        </p>
        <pre><code># GAZEBO 11<br><br>install(<br>  DIRECTORY<br>    ...<br>    # GLOBAL_NAVIGATION<br>    taxi_navigator/models<br>    ...<br>  DESTINATION share/${PROJECT_NAME})</code></pre>
        <pre><code># GAZEBO HARMONIC<br><br>install(<br>  DIRECTORY<br>    ...<br>    # GLOBAL_NAVIGATION<br>    taxi_navigator/launch<br>    taxi_navigator/models<br>    taxi_navigator/worlds<br>    taxi_navigator/params<br>    ...<br>  DESTINATION share/${PROJECT_NAME})</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/Launchers/global_navigation/spawn_robot.launch.py
        </strong></p>
        <p>
            Una vez creado el directorio <strong>global_navigation/</strong>, y a su vez dentro 
            de él el fichero <strong>spawn_robot.launch.py</strong>, lo único que habría que 
            hacer es coger cualquier fichero con el mismo nombre de otro ejercicio que ya esté 
            migrado a Gazebo Harmonic, copiar su contenido y sólamente habría que comentar todo 
            lo relativo a las variables <strong>start_gazebo_ros_image_bridge_cmd</strong> y 
            <strong>start_gazebo_ros_depth_bridge_cmd</strong>, y lo más importante, modificar 
            el nombre del fichero que se le pasa como argumento a bridge_params (en este caso, 
            <strong>taxi_holo_ROS_harmonic.yaml</strong>):
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/Launchers/taxi_navigator.launch.py
        </strong></p>
        <p>
            Para este fichero, lo único que habría que hacer es un Ctrl+C Ctrl+V de 
            cualquier fichero con el mismo formato de nombre que ya haya sido migrado a Gazebo 
            Harmonic y modificar únicamente las líneas correspondientes a las 
            variables <strong>robot_launch_dir</strong> y <strong>world_file_name</strong>, 
            correspondientes a las rutas en las que se encuentran el directorio que almacena el 
            fichero <strong>spawn_robot.launch.py</strong> y el fichero del mundo que utiliza 
            este ejercicio.
        </p>
        <pre><code>CODE</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: En caso de que no se haya creado dentro del directorio 
            <strong>global_navigation/</strong> el fichero 
            <strong>robot_state_publisher.launch.py</strong>, es obligatorio comentar 
            y/o eliminar del código todo lo relacionado con la variable 
            <strong>robot_state_publisher_cmd</strong>.
        </p>

        <p><strong>
            FICHERO RoboticsInfrastructure/Worlds/taxi_navigation_city_large.world
        </strong></p>
        <p>
            En este fichero, lo único que habría que realizar es un Ctrl+C Ctrl+V de 
            cualquier fichero con el mismo formato de nombre que ya haya sido migrado a Gazebo 
            Harmonic y sustituir todas aquellos flags &lt;include&gt; de la versión antigua por 
            aquellos que aparezcan en la versión nueva.
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/database/universes.sql
        </strong></p>
        <p>
            Este es uno de los cambios más sencillos de realizar en todo el proceso de migración.
            Lo único que habría que hacer es identificar el ejercicio que se quiere migrar de 
            Gazebo 11 a Gazebo Harmonic (en este caso, Global Navigation) y cambiar el valor de 
            la columna <strong>type</strong> de <strong>gazebo</strong> a <strong>gz</strong>:
        </p>
        <pre><code># GAZEBO 11<br>8	City Large	/opt/jderobot/Launchers/taxi_navigator.launch.py	None	ROS2	gazebo	{0.0,0.0,0.0,0.0,0.0,0.0}</code></pre>
        <pre><code># GAZEBO HARMONIC<br>8	City Large	/opt/jderobot/Launchers/taxi_navigator.launch.py	None	ROS2	gz	{0.0,0.0,0.0,0.0,0.0,0.0}</code></pre>

        <p>
            Una vez realizados todos estos cambios en todos los ficheros mencionados, 
            he hecho commit y push en una nueva rama que he creado y publicado llamada 
            <strong>global-navigation-migration</strong>. Es importante hacer esto siempre para 
            así evitar cualquier tipo de conflicto con la rama principal.
        </p>

        <p>
            Como todos los cambios se han realizado en ficheros que se encuentran dentro de 
            RoboticsInfrastructure, es obligatorio generar un nuevo RADI. Para ello, se deben 
            ejecutar los siguientes comandos en la terminal:
        </p>
        <pre><code>cd scripts/RADI/</code></pre>
        <pre><code>./build.sh -i global-navigation-migration</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: Cada vez que se genera un nuevo RADI no se borra el 
            anterior, por lo que el espacio disponible en disco se irá llenando y llenando 
            cada vez que se genere un nuevo RADI hasta que no quede espacio disponible en disco.
            Para evitar que esto ocurra, se debe ejecutar el siguiente comando en la terminal, 
            el cual se encargará de borrar todo el espacio de memoria que se ha ido llenando por 
            cada RADI generado:
        </p>
        <pre><code>docker system prune -af</code></pre>

        <p>
            Una vez finalizada la ejecución del script <strong>build.sh</strong>, se debe 
            regresar al repositorio principal:
        </p>
        <pre><code>cd ../..</code></pre>

        <p>
            Pero antes de ejecutar el script <strong>develop_academy.sh</strong>, hay que 
            modificar la siguiente línea del fichero 
            <strong>RoboticsAcademy/compose_cfg/dev_humble_cpu.yaml</strong>:
        </p>
        <pre><code># ANTES<br>  robotics-academy:<br>    image: jderobot/robotics-academy:latest<br><br># DESPUÉS<br>  robotics-academy:<br>    image: jderobot/robotics-academy:test</code></pre>

        <p>
            Con este cambio ya realizado, ya se puede lanzar el script 
            <strong>develop_academy.sh</strong>:
        </p>
        <pre><code>./scripts/develop_academy.sh</code></pre>

        <p>
            Y por último, sólo quedaría acceder a la dirección web `http://0.0.0.0:7164/` que 
            aparece en la terminal al ejecutar el comando anterior para poder entrar a Unibotics 
            en local y verificar que los cambios se han realizado correctamente.
        </p>

        <p>
            A continuación se muestra cómo se ve el ejercicio <strong>Global Navigation</strong> 
            al lanzar el Docker de RoboticsAcademy con todos estos cambios realizados:
        </p>
        <p>
        <div style="place-items: center">
            <img src="images/semana04/global_navigation_image.png" alt="Global Navigation Image" class="screenshot">
        </div>
        </p>
        <p>
            Además, para verificar que tanto el escenario como el coche han sido migrados 
            correctamente, se muestra una pequeña animación del coche moviéndose en línea 
            recta para verificar que todo el proceso se ha realizado correctamente:
        </p>
        <video width="960" height="540" controls style="display: block; margin: 0 auto;" poster="images/semana04/global_navigation_image.png">
            <source src="videos/semana04/global_navigation_video.mp4" type="video/mp4">
        </video>
    </div>

    <!-- Entrada de blog (semana 05) -->
    <div id="entry-5" class="entry">
        <p class="date">SEMANA 05: 20-10-2025 al 24-10-2025</p>

        <h1>
            Migración del ejercicio Autoparking a Gazebo Harmonic
        </h1>

        <p>
            Con el ejercicio de Global Navigation ya migrado por completo a Gazebo Harmonic, 
            se me ha pedido realizar la migración completa de Gazebo 11 a Gazebo Harmonic de un 
            tercer ejercicio, en este caso, <strong>Autoparking</strong>, que consiste en la 
            implementación de la lógica de un algoritmo de navegación en un vehículo autónomo 
            que se encuentra buscando aparcamiento.
        </p>

        <div style="place-items: center">
            <img src="images/semana05/autoparking_exercise.png" alt="Autoparking Exercise" class="screenshot">
        </div>
        <p><strong>ENLACE AL ENUNCIADO DEL EJERCICIO</strong>: <a href="https://jderobot.github.io/RoboticsAcademy/exercises/AutonomousCars/autoparking/">https://jderobot.github.io/RoboticsAcademy/exercises/AutonomousCars/autoparking/</a></p>

        <p>
            A continuación, se encuentran todos los ficheros que se han modificado y/o creado
            (y de qué forma) para poder llevar a cabo la migración completa de este ejercicio
            de Gazebo 11 a Gazebo Harmonic:
        </p>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/&lt;robot_model_name&gt;/models/&lt;robot_model_name&gt;/model.sdf
        </strong></p>
        <p>
            En este caso, no ha sido necesario llevar a cabo ninguna modificación en este 
            fichero, ya que el coche utilizado para esta versión ya se encuentra migrado a 
            Gazebo Harmonic:
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/&lt;robot_model_name&gt;/params/&lt;robot_model_name&gt;.yaml
        </strong></p>
        <p>
            Este fichero se crea de cero en la ruta especificada, aunque se puede coger 
            cualquier fichero del tipo <strong>robot_params.yaml</strong> como referencia. 
            En este caso, se añaden los topics correspondientes al plugin subscriptor del 
            DiffDrive, y los plugin publicadores del DiffDrive, del sensor láser LIDAR y de 
            la cámara.
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/CMakeLists.txt
        </strong></p>
        <p>
            En este caso, la única modificación realizada en este fichero es la 
            adición de las líneas [...], 
            para que el fichero que se acaba de crear (<strong>&lt;robot_model_name&gt;.yaml</strong>),
            se tenga en cuenta a la hora de lanzar el Docker:
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/Launchers/&lt;exercise_name&gt;/spawn_robot.launch.py
        </strong></p>
        <p>
            Una vez creado el directorio <strong>&lt;exercise_name&gt;/</strong>, y a su vez dentro 
            de él el fichero <strong>spawn_robot.launch.py</strong>, lo único que habría que 
            hacer es coger cualquier fichero con el mismo nombre de otro ejercicio que ya esté 
            migrado a Gazebo Harmonic, copiar su contenido y sólamente habría que comentar todo 
            lo relativo a las variables <strong>start_gazebo_ros_image_bridge_cmd</strong> y 
            <strong>start_gazebo_ros_depth_bridge_cmd</strong>, y lo más importante, modificar 
            el nombre del fichero que se le pasa como argumento a bridge_params (en este caso, 
            <strong>&lt;robot_model_name&gt;.yaml</strong>):
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/Launchers/&lt;robot_model_name&gt;.launch.py
        </strong></p>
        <p>
            Para este fichero, lo único que habría que hacer es un Ctrl+C Ctrl+V de 
            cualquier fichero con el mismo formato de nombre que ya haya sido migrado a Gazebo 
            Harmonic y modificar únicamente las líneas correspondientes a las 
            variables <strong>robot_launch_dir</strong> y <strong>world_file_name</strong>, 
            correspondientes a las rutas en las que se encuentran el directorio que almacena el 
            fichero <strong>spawn_robot.launch.py</strong> y el fichero del mundo que utiliza 
            este ejercicio.
        </p>
        <pre><code>CODE</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: En caso de que no se haya creado dentro del directorio 
            <strong>&lt;exercise_name&gt;/</strong> el fichero 
            <strong>robot_state_publisher.launch.py</strong>, es obligatorio comentar 
            y/o eliminar del código todo lo relacionado con la variable 
            <strong>robot_state_publisher_cmd</strong>.
        </p>

        <p><strong>
            FICHERO RoboticsInfrastructure/Worlds/&lt;world_name&gt;.world
        </strong></p>
        <p>
            En este fichero, lo único que habría que realizar es un Ctrl+C Ctrl+V de 
            cualquier fichero con el mismo formato de nombre que ya haya sido migrado a Gazebo 
            Harmonic y sustituir todas aquellos flags &lt;include&gt; de la versión antigua por 
            aquellos que aparezcan en la versión nueva.
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/database/universes.sql
        </strong></p>
        <p>
            Este es uno de los cambios más sencillos de realizar en todo el proceso de migración.
            Lo único que habría que hacer es identificar el ejercicio que se quiere migrar de 
            Gazebo 11 a Gazebo Harmonic (en este caso, Autoparking) y cambiar el valor de la 
            columna <strong>type</strong> de <strong>gazebo</strong> a <strong>gz</strong>:
        </p>
        <pre><code>CODE</code></pre>

        <p>
            Una vez realizados todos estos cambios en todos los ficheros mencionados, 
            he hecho commit y push en una nueva rama que he creado y publicado llamada 
            <strong>autopark_harmonic</strong>. Es importante hacer esto siempre para 
            así evitar cualquier tipo de conflicto con la rama principal.
        </p>

        <p>
            Como todos los cambios se han realizado en ficheros que se encuentran dentro de 
            RoboticsInfrastructure, es obligatorio generar un nuevo RADI. Para ello, se deben 
            ejecutar los siguientes comandos en la terminal:
        </p>
        <pre><code>cd scripts/RADI/</code></pre>
        <pre><code>./build.sh -i autopark_harmonic</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: Cada vez que se genera un nuevo RADI no se borra el 
            anterior, por lo que el espacio disponible en disco se irá llenando y llenando 
            cada vez que se genere un nuevo RADI hasta que no quede espacio disponible en disco.
            Para evitar que esto ocurra, se debe ejecutar el siguiente comando en la terminal, 
            el cual se encargará de borrar todo el espacio de memoria que se ha ido llenando por 
            cada RADI generado:
        </p>
        <pre><code>docker system prune -af</code></pre>

        <p>
            Una vez finalizada la ejecución del script <strong>build.sh</strong>, se debe 
            regresar al repositorio principal:
        </p>
        <pre><code>cd ../..</code></pre>

        <p>
            Pero antes de ejecutar el script <strong>develop_academy.sh</strong>, hay que 
            modificar la siguiente línea del fichero 
            <strong>RoboticsAcademy/compose_cfg/dev_humble_cpu.yaml</strong>:
        </p>
        <pre><code># ANTES<br>  robotics-academy:<br>    image: jderobot/robotics-academy:latest<br><br># DESPUÉS<br>  robotics-academy:<br>    image: jderobot/robotics-academy:test</code></pre>

        <p>
            Con este cambio ya realizado, ya se puede lanzar el script 
            <strong>develop_academy.sh</strong>:
        </p>
        <pre><code>./scripts/develop_academy.sh</code></pre>

        <p>
            Y por último, sólo quedaría acceder a la dirección web `http://0.0.0.0:7164/` que 
            aparece en la terminal al ejecutar el comando anterior para poder entrar a Unibotics 
            en local y verificar que los cambios se han realizado correctamente.
        </p>

        <p>
            A continuación se muestra cómo se ve el ejercicio <strong>Autoparking</strong> 
            al lanzar el Docker de RoboticsAcademy con todos estos cambios realizados:
        </p>
        <p>
            <strong>IMAGEN UNIBOTICS GAZEBO AUTOPARKING</strong>
        </p>
        <p>
            Además, para verificar que tanto el escenario como el coche han sido migrados 
            correctamente, se muestra una pequeña animación del coche moviéndose en línea 
            recta para verificar que todo el proceso se ha realizado correctamente:
        </p>
        <p>
            <strong>VÍDEO / GIF COCHE MOVIÉNDOSE POR EL ESCENARIO</strong>
        </p>

    </div>

    <!-- Entrada de blog (semana 06) -->
    <div id="entry-6" class="entry">
        <p class="date">SEMANA 06: 27-10-2025 al 31-10-2025</p>

        <h1>
            Migración del ejercicio Follow Line a Gazebo Harmonic
        </h1>

        <p>
            Con el ejercicio de Autoparking ya migrado por completo a Gazebo Harmonic, 
            se me ha pedido realizar la migración completa de Gazebo 11 a Gazebo Harmonic de un 
            cuarto ejercicio, en este caso, <strong>Follow Line</strong>, que consiste en la 
            implementación de un controlador PID reactivo que sea capaz de seguir la línea roja 
            pintada en el suelo del circuito de carreras.
        </p>

        <div style="place-items: center">
            <img src="images/semana06/follow_line_exercise.png" alt="Follow Line Exercise" class="screenshot">
        </div>
        <p><strong>ENLACE AL ENUNCIADO DEL EJERCICIO</strong>: <a href="https://jderobot.github.io/RoboticsAcademy/exercises/AutonomousCars/follow_line/">https://jderobot.github.io/RoboticsAcademy/exercises/AutonomousCars/follow_line/</a></p>

        <p>
            A continuación, se encuentran todos los ficheros que se han modificado y/o creado
            (y de qué forma) para poder llevar a cabo la migración completa de este ejercicio
            de Gazebo 11 a Gazebo Harmonic:
        </p>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/&lt;robot_model_name&gt;/models/&lt;robot_model_name&gt;/model.sdf
        </strong></p>
        <p>
            En este caso, no ha sido necesario llevar a cabo ninguna modificación en este 
            fichero, ya que el coche utilizado para esta versión ya se encuentra migrado a 
            Gazebo Harmonic:
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/&lt;robot_model_name&gt;/params/&lt;robot_model_name&gt;.yaml
        </strong></p>
        <p>
            Este fichero se crea de cero en la ruta especificada, aunque se puede coger 
            cualquier fichero del tipo <strong>robot_params.yaml</strong> como referencia. 
            En este caso, se añaden los topics correspondientes al plugin subscriptor del 
            DiffDrive, y los plugin publicadores del DiffDrive, del sensor láser LIDAR y de 
            la cámara.
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/CustomRobots/CMakeLists.txt
        </strong></p>
        <p>
            En este caso, la única modificación realizada en este fichero es la 
            adición de las líneas [...], 
            para que el fichero que se acaba de crear (<strong>&lt;robot_model_name&gt;.yaml</strong>),
            se tenga en cuenta a la hora de lanzar el Docker:
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/Launchers/&lt;exercise_name&gt;/spawn_robot.launch.py
        </strong></p>
        <p>
            Una vez creado el directorio <strong>&lt;exercise_name&gt;/</strong>, y a su vez dentro 
            de él el fichero <strong>spawn_robot.launch.py</strong>, lo único que habría que 
            hacer es coger cualquier fichero con el mismo nombre de otro ejercicio que ya esté 
            migrado a Gazebo Harmonic, copiar su contenido y sólamente habría que comentar todo 
            lo relativo a las variables <strong>start_gazebo_ros_image_bridge_cmd</strong> y 
            <strong>start_gazebo_ros_depth_bridge_cmd</strong>, y lo más importante, modificar 
            el nombre del fichero que se le pasa como argumento a bridge_params (en este caso, 
            <strong>&lt;robot_model_name&gt;.yaml</strong>):
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/Launchers/&lt;robot_model_name&gt;.launch.py
        </strong></p>
        <p>
            Para este fichero, lo único que habría que hacer es un Ctrl+C Ctrl+V de 
            cualquier fichero con el mismo formato de nombre que ya haya sido migrado a Gazebo 
            Harmonic y modificar únicamente las líneas correspondientes a las 
            variables <strong>robot_launch_dir</strong> y <strong>world_file_name</strong>, 
            correspondientes a las rutas en las que se encuentran el directorio que almacena el 
            fichero <strong>spawn_robot.launch.py</strong> y el fichero del mundo que utiliza 
            este ejercicio.
        </p>
        <pre><code>CODE</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: En caso de que no se haya creado dentro del directorio 
            <strong>&lt;exercise_name&gt;/</strong> el fichero 
            <strong>robot_state_publisher.launch.py</strong>, es obligatorio comentar 
            y/o eliminar del código todo lo relacionado con la variable 
            <strong>robot_state_publisher_cmd</strong>.
        </p>

        <p><strong>
            FICHERO RoboticsInfrastructure/Worlds/&lt;world_name&gt;.world
        </strong></p>
        <p>
            En este fichero, lo único que habría que realizar es un Ctrl+C Ctrl+V de 
            cualquier fichero con el mismo formato de nombre que ya haya sido migrado a Gazebo 
            Harmonic y sustituir todas aquellos flags &lt;include&gt; de la versión antigua por 
            aquellos que aparezcan en la versión nueva.
        </p>
        <pre><code>CODE</code></pre>

        <p><strong>
            FICHERO RoboticsInfrastructure/database/universes.sql
        </strong></p>
        <p>
            Este es uno de los cambios más sencillos de realizar en todo el proceso de migración.
            Lo único que habría que hacer es identificar el ejercicio que se quiere migrar de 
            Gazebo 11 a Gazebo Harmonic (en este caso, Follow Line) y cambiar el valor de la 
            columna <strong>type</strong> de <strong>gazebo</strong> a <strong>gz</strong>:
        </p>
        <pre><code>CODE</code></pre>

        <p>
            Una vez realizados todos estos cambios en todos los ficheros mencionados, 
            he hecho commit y push en una nueva rama que he creado y publicado llamada 
            <strong>harmonic-follow-line-tests</strong>. Es importante hacer esto siempre para 
            así evitar cualquier tipo de conflicto con la rama principal.
        </p>

        <p>
            Como todos los cambios se han realizado en ficheros que se encuentran dentro de 
            RoboticsInfrastructure, es obligatorio generar un nuevo RADI. Para ello, se deben 
            ejecutar los siguientes comandos en la terminal:
        </p>
        <pre><code>cd scripts/RADI/</code></pre>
        <pre><code>./build.sh -i harmonic-follow-line-tests</code></pre>
        <p>
            <strong>IMPORTANTE</strong>: Cada vez que se genera un nuevo RADI no se borra el 
            anterior, por lo que el espacio disponible en disco se irá llenando y llenando 
            cada vez que se genere un nuevo RADI hasta que no quede espacio disponible en disco.
            Para evitar que esto ocurra, se debe ejecutar el siguiente comando en la terminal, 
            el cual se encargará de borrar todo el espacio de memoria que se ha ido llenando por 
            cada RADI generado:
        </p>
        <pre><code>docker system prune -af</code></pre>

        <p>
            Una vez finalizada la ejecución del script <strong>build.sh</strong>, se debe 
            regresar al repositorio principal:
        </p>
        <pre><code>cd ../..</code></pre>

        <p>
            Pero antes de ejecutar el script <strong>develop_academy.sh</strong>, hay que 
            modificar la siguiente línea del fichero 
            <strong>RoboticsAcademy/compose_cfg/dev_humble_cpu.yaml</strong>:
        </p>
        <pre><code># ANTES<br>  robotics-academy:<br>    image: jderobot/robotics-academy:latest<br><br># DESPUÉS<br>  robotics-academy:<br>    image: jderobot/robotics-academy:test</code></pre>

        <p>
            Con este cambio ya realizado, ya se puede lanzar el script 
            <strong>develop_academy.sh</strong>:
        </p>
        <pre><code>./scripts/develop_academy.sh</code></pre>

        <p>
            Y por último, sólo quedaría acceder a la dirección web `http://0.0.0.0:7164/` que 
            aparece en la terminal al ejecutar el comando anterior para poder entrar a Unibotics 
            en local y verificar que los cambios se han realizado correctamente.
        </p>

        <p>
            A continuación se muestra cómo se ve el ejercicio <strong>Follow Line</strong> 
            al lanzar el Docker de RoboticsAcademy con todos estos cambios realizados:
        </p>
        <p>
            <strong>IMAGEN UNIBOTICS GAZEBO FOLLOW LINE</strong>
        </p>
        <p>
            Además, para verificar que tanto el escenario como el coche han sido migrados 
            correctamente, se muestra una pequeña animación del coche moviéndose en línea 
            recta para verificar que todo el proceso se ha realizado correctamente:
        </p>
        <p>
            <strong>VÍDEO / GIF COCHE MOVIÉNDOSE POR EL ESCENARIO</strong>
        </p>
    </div>

    <!-- Entrada de blog (semana 07) -->
    <div id="entry-7" class="entry">
        <p class="date">SEMANA 07: 03-11-2025 al 07-11-2025</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 08) -->
    <div id="entry-8" class="entry">
        <p class="date">SEMANA 08: 10-11-2025 al 14-11-2025</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 09) -->
    <div id="entry-9" class="entry">
        <p class="date">SEMANA 09: 17-11-2025 al 21-11-2025</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 10) -->
    <div id="entry-10" class="entry">
        <p class="date">SEMANA 10: 24-11-2025 al 28-11-2025</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 11) -->
    <div id="entry-11" class="entry">
        <p class="date">SEMANA 11: 01-12-2025 al 05-12-2025</p>
        <p>
            ...
        </p>
    </div>
    
    <!-- Entrada de blog (semana 12) -->
    <div id="entry-12" class="entry">
        <p class="date">SEMANA 12: 08-12-2025 al 12-12-2025</p>
        <p>
            ...
        </p>
    </div>
    
    <!-- Entrada de blog (semana 13) -->
    <div id="entry-13" class="entry">
        <p class="date">SEMANA 13: 15-12-2025 al 19-12-2025</p>
        <p>
            ...
        </p>
    </div>
    
    <!-- Entrada de blog (semana 14) -->
    <div id="entry-14" class="entry">
        <p class="date">SEMANA 14: 22-12-2025 al 26-12-2025</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 15) -->
    <div id="entry-15" class="entry">
        <p class="date">SEMANA 15: 29-12-2025 al 02-01-2026</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 16) -->
    <div id="entry-16" class="entry">
        <p class="date">SEMANA 16: 05-01-2026 al 09-01-2026</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 17) -->
    <div id="entry-17" class="entry">
        <p class="date">SEMANA 17: 12-01-2026 al 16-01-2026</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 18) -->
    <div id="entry-18" class="entry">
        <p class="date">SEMANA 18: 19-01-2026 al 23-01-2026</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 19) -->
    <div id="entry-19" class="entry">
        <p class="date">SEMANA 19: 26-01-2026 al 30-01-2026</p>
        <p>
            ...
        </p>
    </div>

    <!-- Entrada de blog (semana 20) -->
    <div id="entry-20" class="entry">
        <p class="date">SEMANA 20: 02-02-2026 al 06-02-2026</p>
        <p>
            ...
        </p>
    </div>

    <!-- Script que va mostrando el contenido de cada entrada -->
    <script>
        function showEntry(week) {
            let entries = document.querySelectorAll('.entry');
            entries.forEach(entry => entry.style.display = 'none');
            document.getElementById('entry-' + week).style.display = 'block';
        }
    </script>

</body>
</html>